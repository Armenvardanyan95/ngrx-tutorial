"use strict";(self.webpackChunkngrx_course=self.webpackChunkngrx_course||[]).push([[649],{5950:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return r},contentTitle:function(){return l},metadata:function(){return h},toc:function(){return d},default:function(){return p}});var a=n(7462),o=n(3366),i=(n(7294),n(3905)),s=["components"],r={title:"Chapter 4: NgRx: The Why",sidebar_position:4},l=void 0,h={unversionedId:"chapter-4",id:"chapter-4",isDocsHomePage:!1,title:"Chapter 4: NgRx: The Why",description:"Why do we need NgRx?",source:"@site/docs/chapter-4.md",sourceDirName:".",slug:"/chapter-4",permalink:"/ngrx-course/docs/chapter-4",editUrl:"https://github.com/this-is-angular/ngrx-course/edit/main/docs/chapter-4.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{title:"Chapter 4: NgRx: The Why",sidebar_position:4},sidebar:"courseSidebar",previous:{title:"Chapter 3: NgRx: The What",permalink:"/ngrx-course/docs/chapter-3"},next:{title:"Chapter 5: Actions",permalink:"/ngrx-course/docs/chapter-5"}},d=[{value:"Why do we need NgRx?",id:"why-do-we-need-ngrx",children:[{value:"Reasonable state",id:"reasonable-state",children:[]},{value:"How do bugs happen?",id:"how-do-bugs-happen",children:[]}]},{value:"What does NgRx offer?",id:"what-does-ngrx-offer",children:[]},{value:"Isn&#39;t this just overengineering?",id:"isnt-this-just-overengineering",children:[]},{value:"What NgRx is <strong>not</strong>",id:"what-ngrx-is-not",children:[]}],c={toc:d};function p(e){var t=e.components,n=(0,o.Z)(e,s);return(0,i.kt)("wrapper",(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h2",{id:"why-do-we-need-ngrx"},"Why do we need NgRx?"),(0,i.kt)("h3",{id:"reasonable-state"},"Reasonable state"),(0,i.kt)("p",null,"As mentioned in the previous chapter, we need a state management solution that is predictable, scalable and easy to reason about. Those might sound like big words, but in reality it simply means the following:"),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"I want to be able to fix bugs without having a migraine")),(0,i.kt)("h3",{id:"how-do-bugs-happen"},"How do bugs happen?"),(0,i.kt)("p",null,"In most cases, we have bugs not because the code is wrong (in that case we essentially didn't tell the computer what ",(0,i.kt)("em",{parentName:"p"},"exactly")," we wanted), but because the data is not in the expected state. The variable ",(0,i.kt)("inlineCode",{parentName:"p"},"age")," all of a sudden holds a negative value, because someone misclicked when the IDE offered an autocomplete or a correction. Or maybe the Array of users is empty, because we called the wrong API, or stored the data in the wrong variable, or forgot to subscribe. Problems like this happen ",(0,i.kt)("em",{parentName:"p"},"all the time"),". Remember the last vry annoying bug you encountered. Was it because of a very minor mistake like a typo? If yes, answer the following: how frustrating was the whole experience?"),(0,i.kt)("h2",{id:"what-does-ngrx-offer"},"What does NgRx offer?"),(0,i.kt)("p",null,"NgRx, as mentioned, is built on concepts of Redux. It utilizes core ideas like ",(0,i.kt)("inlineCode",{parentName:"p"},"Stores")," (the place where the application states is stored), ",(0,i.kt)("inlineCode",{parentName:"p"},"Actions")," (events that notify the ",(0,i.kt)("inlineCode",{parentName:"p"},"Store")," that some change to the state is to happen), ",(0,i.kt)("inlineCode",{parentName:"p"},"Reducers")," (functions that determine how a certain ",(0,i.kt)("inlineCode",{parentName:"p"},"Action")," affects the ",(0,i.kt)("inlineCode",{parentName:"p"},"State"),"), and also adds concepts like ",(0,i.kt)("inlineCode",{parentName:"p"},"Selectors")," (functions that allow to pick a slice of the ",(0,i.kt)("inlineCode",{parentName:"p"},"State")," as an ",(0,i.kt)("inlineCode",{parentName:"p"},"Observable"),") and ",(0,i.kt)("inlineCode",{parentName:"p"},"Effects")," (special functions that work on side effects like data loading and API calls). It also provides utility functions to make writing boilerplate code easier and even utility libraries like ",(0,i.kt)("inlineCode",{parentName:"p"},"@ngrx/entity")," to work with large lists of data. We will learn in depth about all of those concepts and tools in corresponding chapters."),(0,i.kt)("p",null,"Together, this tools allow us to build a truly scalable state management solution."),(0,i.kt)("h2",{id:"isnt-this-just-overengineering"},"Isn't this just overengineering?"),(0,i.kt)("p",null,'At this point you might think "again, I don\'t need all of these ideas and abstract concepts. In practice, my app works fine!". But think about how scalable your architecture is. Will it be easy to incorporate more and more interconnected relations between layers and components of your app? Will it be easy to add new modules that depend on existing data as well as introduce new states? If you overthink now, know that NgRx got you covered.'),(0,i.kt)("h2",{id:"what-ngrx-is-not"},"What NgRx is ",(0,i.kt)("strong",{parentName:"h2"},"not")),(0,i.kt)("p",null,'Some developers assume that "better architecture" means "less code". This is far from true. Actually, sometimes it is better to have a few more lines of code that are explicit and simple rather than a very short, but mystical algorithm. NgRx certainly ',(0,i.kt)("strong",{parentName:"p"},"does not")," reduce the lines of code (LOC). Sure, your components will become simpler and have less LOC (which is part of our goal), but instead we will write lots of ",(0,i.kt)("inlineCode",{parentName:"p"},"Actions"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"Reducers")," and so on, which will definitely compensate for the small gains that we receive in the component class code. So why bother? Because in return we will get simplicity that we so much desire"),(0,i.kt)("p",null,"So, let's finally get down to learning those concepts and putting them into practice."))}p.isMDXComponent=!0}}]);