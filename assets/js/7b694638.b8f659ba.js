"use strict";(self.webpackChunkngrx_course=self.webpackChunkngrx_course||[]).push([[870],{3802:function(e,t,a){a.r(t),a.d(t,{frontMatter:function(){return i},contentTitle:function(){return l},metadata:function(){return d},toc:function(){return p},default:function(){return c}});var n=a(7462),o=a(3366),r=(a(7294),a(3905)),s=["components"],i={title:"Chapter 12: NgRx and Lazy Loading",sidebar_position:12},l=void 0,d={unversionedId:"chapter-12",id:"chapter-12",isDocsHomePage:!1,title:"Chapter 12: NgRx and Lazy Loading",description:"Feature states",source:"@site/docs/chapter-12.md",sourceDirName:".",slug:"/chapter-12",permalink:"/ngrx-course/docs/chapter-12",editUrl:"https://github.com/this-is-angular/ngrx-course/edit/main/docs/chapter-12.md",tags:[],version:"current",sidebarPosition:12,frontMatter:{title:"Chapter 12: NgRx and Lazy Loading",sidebar_position:12},sidebar:"courseSidebar",previous:{title:"Chapter 11: Effects in depth",permalink:"/ngrx-course/docs/chapter-11"}},p=[{value:"Feature states",id:"feature-states",children:[]},{value:"NgRx Feature states",id:"ngrx-feature-states",children:[]},{value:"Preparing for feature states",id:"preparing-for-feature-states",children:[]},{value:"Lazy loading feature states",id:"lazy-loading-feature-states",children:[]},{value:"Where to be careful",id:"where-to-be-careful",children:[]},{value:"Homework",id:"homework",children:[]}],u={toc:p};function c(e){var t=e.components,a=(0,o.Z)(e,s);return(0,r.kt)("wrapper",(0,n.Z)({},u,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h2",{id:"feature-states"},"Feature states"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://angular.io/guide/lazy-loading-ngmodules"},"Lazy loading")," is an important Angular feature that boosts performance and allows for better, modular architecture. Basically, we split our app into feature modules, each corresponding to some app-specific feature, and then load those modules when needed (when the user navigates to them). Lazy loading is a built-in feature in Angular."),(0,r.kt)("p",null,"So how does NgRx relate to this? Let's examine the structure of our app to understand better."),(0,r.kt)("p",null,"In our financial logger app we have at least two features: categories and logs. We might want to have pages that show all the logs, add new logs, add categories, and so on, so it makes sense to keep them separated."),(0,r.kt)("p",null,"But we have mentioned that the ",(0,r.kt)("inlineCode",{parentName:"p"},"State")," in our ",(0,r.kt)("inlineCode",{parentName:"p"},"Store")," is basically a large global object with no write access, meaning that we probably would want to define all the feature state slices beforehand; but that would kind of break the lazy loading logic: if the user never visits the category module pages, why would we even have any state related to categories stored?"),(0,r.kt)("p",null,"Thankfully, NgRx got us covered."),(0,r.kt)("h2",{id:"ngrx-feature-states"},"NgRx Feature states"),(0,r.kt)("p",null,"In NgRx, data from the lazy loaded modules can be stored in what is called Feature states; basically, our ",(0,r.kt)("inlineCode",{parentName:"p"},"Store")," now will contain data like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"export interface AppState {\n  categories: CategoryState;\n  logs: LogState;\n}\n")),(0,r.kt)("p",null,"The trick here being that, say, ",(0,r.kt)("inlineCode",{parentName:"p"},"logs")," is undefined from the start of the application until the user visits a page from the ",(0,r.kt)("inlineCode",{parentName:"p"},"LogsModule"),"."),(0,r.kt)("h2",{id:"preparing-for-feature-states"},"Preparing for feature states"),(0,r.kt)("p",null,"Let us first create our first lazy loaded module: ",(0,r.kt)("inlineCode",{parentName:"p"},"LogsModule")," and include it in our routing. Now, because ",(0,r.kt)("inlineCode",{parentName:"p"},"LogsModule")," is a separate entity, it is going to have a separate ",(0,r.kt)("inlineCode",{parentName:"p"},"State"),". Inside ",(0,r.kt)("inlineCode",{parentName:"p"},"LogsModule"),", create a folder named ",(0,r.kt)("inlineCode",{parentName:"p"},"state"),", with the same files we have in the root directory ",(0,r.kt)("inlineCode",{parentName:"p"},"state")," folder. Then, let's design our feature state:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'// src/app/logs/state/state.ts\nexport enum LogType {\n  Spend = "Spend",\n  Income = "Income",\n}\n\nexport interface Log {\n  title: string;\n  date: string;\n  amount: number;\n  type: LogType;\n  categoryId: number;\n}\n\nexport interface LogsState {\n  logs: Log[];\n  loading: {\n    list: boolean;\n    add: boolean;\n  };\n}\n\nexport const initialState: LogsState = {\n  logs: [],\n  loading: {\n    list: false,\n    add: false,\n  },\n};\n')),(0,r.kt)("p",null,"So this is how our feature state will look like. It does not reference anything from the ",(0,r.kt)("inlineCode",{parentName:"p"},"AppState"),", which is good, as our module is independent and lazy loaded. So how do we connect this independent state with the global, ",(0,r.kt)("inlineCode",{parentName:"p"},"AppState"),"? First, we will have to write a reducer. In the ",(0,r.kt)("inlineCode",{parentName:"p"},"database.json")," file we also have a nested object called ",(0,r.kt)("inlineCode",{parentName:"p"},"logs"),", which is an empty array. For the purpose of providing the opportunity to grow experience, we will skip writing the reducer and allow the reader to do that themselves."),(0,r.kt)("p",null,"Write a ",(0,r.kt)("inlineCode",{parentName:"p"},"logsReducer")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"LogsEffects")," and come back to this chapter."),(0,r.kt)("h2",{id:"lazy-loading-feature-states"},"Lazy loading feature states"),(0,r.kt)("p",null,"Now our states are inside a lazy loaded modules. How do we plug them into the existing ",(0,r.kt)("inlineCode",{parentName:"p"},"Store"),"? Turns out, this is pretty easy. In the ",(0,r.kt)("inlineCode",{parentName:"p"},"logs.module.ts"),", add these lines:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'// src/app/logs/logs.module.ts\n\n// import statements omitted\n\n@NgModule({\n  // other metadata\n  imports: [\n    // other imports\n    StoreModule.forFeature("logsFeature", logsReducer),\n    EffectsModule.forFeature([LogsEffects]),\n  ],\n})\nexport class LogsModule {}\n')),(0,r.kt)("p",null,"As you have noticed, instead of ",(0,r.kt)("inlineCode",{parentName:"p"},"forRoot")," we used methods called ",(0,r.kt)("inlineCode",{parentName:"p"},"forFeature"),", which indicate these are reducers and effects tht are being added dynamically, after the user visits this particular module. The ",(0,r.kt)("inlineCode",{parentName:"p"},"StoreModule.forFeature")," method's first argument is the name of the feature state, which is being used when writing feature specific selectors. Let's now write a selector that gets the list of logs (the empty array from the beginning of the chapter)."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"// src/app/logs/state/selectors.ts\n\nexport const logs = (state: AppState) => state.logsFeature.logs;\n")),(0,r.kt)("p",null,"The name ",(0,r.kt)("inlineCode",{parentName:"p"},"logsFeature")," comes from the ",(0,r.kt)("inlineCode",{parentName:"p"},"StoreModule.forFeature")," method's first argument. NgRx provides an easy way to make less boilerplate and not have to use that name each time, by using a special ",(0,r.kt)("inlineCode",{parentName:"p"},"createFeatureSelector")," function. Let's rewrite our selector and see it in action:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'// src/app/logs/state/selectors.ts\n\nconst logsFeature = createFeatureSelector("logsFeature");\n\nexport const logs = createSelector(logsFeature, (state) => state.logs); // state here is already the logsFeature `State`\n')),(0,r.kt)("p",null,"I personally use a small trick to write even less code:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'// src/app/logs/state/selectors.ts\n\nconst logsFeature = createFeatureSelector("logsFeature");\nconst selector = <T>(mapping: (state: LogsState) => T) =>\n  createSelector(logsFeature, mapping);\nexport const logs = selector((state) => state.logs);\n')),(0,r.kt)("p",null,"Now our own ",(0,r.kt)("inlineCode",{parentName:"p"},"selector"),' function is a small wrapper (or a type of functions known as "partial application") around ',(0,r.kt)("inlineCode",{parentName:"p"},"createSelector"),", which always provides the first argument, so we don't have to type it every time."),(0,r.kt)("p",null,"Now we already have a functioning lazy loaded feature state."),(0,r.kt)("h2",{id:"where-to-be-careful"},"Where to be careful"),(0,r.kt)("p",null,"Notice that our ",(0,r.kt)("inlineCode",{parentName:"p"},"AppState")," is and remains a single, unique object. It is just that before the lazy loaded routes are visited, the corresponding nested feature states are ",(0,r.kt)("inlineCode",{parentName:"p"},"undefined"),". So this may create some problems in the future if we are not careful. Imagine a scenario when we have new module, that now needs the ",(0,r.kt)("inlineCode",{parentName:"p"},"logs")," data. Because ",(0,r.kt)("inlineCode",{parentName:"p"},"logs")," is a lazy loaded feature, that data may or may not be available depending on whether the user had previously visited the ",(0,r.kt)("inlineCode",{parentName:"p"},"logs")," routed pages. So if we need some data somewhere, we have to make sure that data is available higher up, and not in another lazy loaded module. As an exercise, try to determine if we need to make the ",(0,r.kt)("inlineCode",{parentName:"p"},"categories")," a separately loaded feature module like ",(0,r.kt)("inlineCode",{parentName:"p"},"logs")),(0,r.kt)("h2",{id:"homework"},"Homework"),(0,r.kt)("p",null,"Homework for this chapter is quite extensive and non-specific: implement the whole lifecycle for financial logs: creating new logs, deleting them, and so on. Future chapters will assume those are implemented, and this will also be an important exercise for our newly acquired skills. If you want any sort of hints and guidance, feel free to take a look at the example app, where all the features are implemented."))}c.isMDXComponent=!0}}]);